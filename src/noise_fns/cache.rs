use crate::noise_fns::NoiseFn;
use std::cell::{Cell, RefCell};
use std::sync::{Arc, Mutex};
use std::collections::HashMap;
use std::mem;

/// Noise function that caches the last output value generated by the source
/// function.
///
/// If the input coordinates passed to `Cache::get` are equal to the previous
/// call, the function returns the cached result of the previous call to
/// `Source::get`. Otherwise, `Source::get` is called with the new coordinates,
/// overwriting the cache with the result, and returning the result to the
/// caller.
///
/// Caching a noise function is useful if it is used as a source function for
/// multiple noise functions. If a source function is not cached, the source
/// function will redundantly calculate the same output value once for each
/// noise function in which it is included.

#[derive(Clone, Debug)]
pub struct Cache<Source> {
    /// Outputs the value to be cached.
    pub source: Source,

    // value: Arc<Mutex<Option<f64>>>,

    // point: Arc<Mutex<Vec<f64>>>,

    cache: HashMap<Vec<u64>, f64>,
}

impl<Source> Cache<Source> {
    pub fn new(source: Source) -> Self {
        Cache {
            source,
            // value: Arc::new(Mutex::new(None)),
            // point: Arc::new(Mutex::new(Vec::new())),
            cache: HashMap::new(),
        }
    }
}

impl<Source> NoiseFn<[f64; 2]> for Cache<Source>
where
    Source: NoiseFn<[f64; 2]>,
{
    fn get(&self, point: [f64; 2]) -> f64 {
        let hash = simple_hash_2d(point);

        match self.cache.get(&hash).map(|entry| entry.clone()) {
            Some(result) => result,
            None => {
                let result = self.source.get(point);
                self.cache.insert(hash, result);
                result
            }
        }

        // match *self.value.lock().unwrap() {
        //     Some(value) if *self.point.lock().unwrap() == point => value,
        //     Some(_) | None => {
        //         let value = self.source.get(point);
        //         *self.value.lock().unwrap() = Some(value);
        //
        //         let mut cached_point = self.point.lock().unwrap().clone();
        //         cached_point.clear();
        //         cached_point.extend_from_slice(&point);
        //
        //         value
        //     }
        // }
    }
}

impl<Source> NoiseFn<[f64; 3]> for Cache<Source>
where
    Source: NoiseFn<[f64; 3]>,
{
    fn get(&self, point: [f64; 3]) -> f64 {
        let hash = simple_hash_3d(point);

        match self.cache.get(&hash).map(|entry| entry.clone()) {
            Some(result) => result,
            None => {
                let result = self.source.get(point);
                self.cache.insert(hash, result);
                result
            }
        }

        // match *self.value.lock().unwrap() {
        //     Some(value) if *self.point.lock().unwrap() == point => value,
        //     Some(_) | None => {
        //         let value = self.source.get(point);
        //         *self.value.lock().unwrap() = Some(value);
        //
        //         let mut cached_point = self.point.lock().unwrap().clone();
        //         cached_point.clear();
        //         cached_point.extend_from_slice(&point);
        //
        //         value
        //     }
        // }
    }
}

impl<Source> NoiseFn<[f64; 4]> for Cache<Source>
where
    Source: NoiseFn<[f64; 4]>,
{
    fn get(&self, point: [f64; 4]) -> f64 {
        let hash = simple_hash_4d(point);

        match self.cache.get(&hash).map(|entry| entry.clone()) {
            Some(result) => result,
            None => {
                let result = self.source.get(point);
                self.cache.insert(hash, result);
                result
            }
        }

        // match *self.value.lock().unwrap() {
        //     Some(value) if *self.point.lock().unwrap() == point => value,
        //     Some(_) | None => {
        //         let value = self.source.get(point);
        //         *self.value.lock().unwrap() = Some(value);
        //
        //         let mut cached_point = self.point.lock().unwrap().clone();
        //         cached_point.clear();
        //         cached_point.extend_from_slice(&point);
        //
        //         value
        //     }
        // }
    }
}

fn integer_decode(val: f64) -> (u64, i16, i8) {
    let bits: u64 = unsafe { mem::transmute(val) };
    let sign: i8 = if bits >> 63 == 0 { 1 } else { -1 };
    let mut exponent: i16 = ((bits >> 52) & 0x7ff) as i16;
    let mantissa = if exponent == 0 {
        (bits & 0xfffffffffffff) << 1
    } else {
        (bits & 0xfffffffffffff) | 0x10000000000000
    };

    exponent -= 1023 + 52;
    (mantissa, exponent, sign)
}

fn simple_hash_2d(point: [f64; 2]) -> Vec<u64> {
    // (a, b, c) = integer_decode(point[0]);
    // (d, e, f) = integer_decode(point[1]);

    // vec![a as i64, b as i64, c as i64, d as i64, e as i64, f as i64]
    let a: u64 = unsafe { mem::transmute(point[0])};
    let b: u64 = unsafe { mem::transmute(point[1])};

    vec![a, b]
}

fn simple_hash_3d(point: [f64; 3]) -> Vec<u64> {
    // (a, b, c) = integer_decode(point[0]);
    // (d, e, f) = integer_decode(point[1]);
    // (g, h, i) = integer_decode(point[1]);

    // vec![a as i64, b as i64, c as i64, d as i64, e as i64, f as i64, g as i64, h as i64, i as i64]
    let a: u64 = unsafe { mem::transmute(point[0])};
    let b: u64 = unsafe { mem::transmute(point[1])};
    let c: u64 = unsafe { mem::transmute(point[2])};

    vec![a, b, c]
}

fn simple_hash_4d(point: [f64; 4]) -> Vec<u64> {
    // (a, b, c) = integer_decode(point[0]);
    // (d, e, f) = integer_decode(point[1]);
    // (g, h, i) = integer_decode(point[1]);

    // vec![a as i64, b as i64, c as i64, d as i64, e as i64, f as i64, g as i64, h as i64, i as i64]
    let a: u64 = unsafe { mem::transmute(point[0])};
    let b: u64 = unsafe { mem::transmute(point[1])};
    let c: u64 = unsafe { mem::transmute(point[2])};
    let d: u64 = unsafe { mem::transmute(point[3])};

    vec![a, b, c, d]
}
